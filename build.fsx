#load ".fake/build.fsx/intellisense.fsx"
open Fake.Core
open Fake.DotNet
open Fake.IO
open Fake.IO.FileSystemOperators
open Fake.IO.Globbing.Operators
open Fake.Core.TargetOperators
open System.Text.RegularExpressions
open System.Xml.Linq

/// given a project name, generate a path to write the concatenated
/// source code found in the project.
let concatFileNamePath projName =
  sprintf "./%s.fs" projName

/// this will be inserted to the top of the concatenated file.
let concatHeader = """(*
The MIT License
prelude.fs - my prelude
Copyright(c) 2018 cannorin
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*)

// this file is automatically generated by build.fsx.
// do not edit this directly.
"""

/// given the common namespace among the source files, generate module/namespace
/// definition that will be placed at the top of the concatenated file.
let fileLevelGrouping name =
  sprintf "[<AutoOpen>]\nmodule internal %s" name

let regex pattern input =
  let m = Regex.Match(input, pattern)
  if m.Success then Some(List.tail [ for g in m.Groups -> g.Value ])
  else None

let inline xname s = XName.Get s

let inline logfailwithf format =
  Printf.kprintf (fun s -> Trace.traceError s; failwith s) format

let concatSources path =
  let proj = MSBuild.loadProject path
  let sources =
    proj.Descendants(xname "Compile")
    |> Seq.map (fun x ->
      let fileName = x.Attribute(xname "Include").Value
      let path = Path.getDirectory path @@ fileName
      fileName, File.read path)
    |> Seq.cache
  
  if sources |> Seq.isEmpty then
    logfailwithf "no source files to concat in the project '%s'." path
  
  let commonNamespace =
    let nss =
      sources
      |> Seq.map (fun (_, source) ->
        source |> Seq.choose (regex @"^namespace +([a-zA-Z_']+).*$") |> Seq.tryHead
      )
    
    if    nss |> Seq.forall Option.isSome
       && (nss |> Seq.distinct |> Seq.length) = 1 then
      nss |> Seq.head |> Option.get |> List.head
    else
      logfailwithf "the source files does not have the same namespace definition"

  let inline isNamespaceLine str =
    let rgx = regex <| sprintf "^namespace +%s.*$" commonNamespace
    rgx str |> Option.isSome
  
  let source = seq {
    yield concatHeader
    yield fileLevelGrouping commonNamespace
    yield ""

    for (fileName, codeLines) in sources do
      yield sprintf "// from: %s" fileName
      yield!
        codeLines |> Seq.skipWhile (not << isNamespaceLine)
                  |> Seq.skipWhile isNamespaceLine
                  |> Seq.skipWhile String.isNullOrWhiteSpace
      yield ""
  }

  let path =
    path |> String.replace (Path.getDirectory path) ""
         |> Path.changeExtension ""
         |> String.trimEndChars [|'.'|]
         |> String.trimChars [|'/'|]
         |> concatFileNamePath
  
  Trace.tracefn "generating '%s'..." path
  File.write false path source

Target.create "Clean" (fun _ ->
  !! "src/**/bin"
  ++ "src/**/obj"
  |> Shell.cleanDirs 
)

Target.create "Build" (fun _ ->
  !! "src/**/*.*proj"
  |> Seq.iter (DotNet.build id)
)


Target.create "Concat" (fun _ ->
  !! "src/**/*.*proj"
  |> Seq.iter concatSources
)

Target.create "All" ignore

"Clean"
  ==> "Build"
  ==> "Concat"
  ==> "All"

Target.runOrDefault "All"
